---
layout: single
title:  "[자료구조] 트리 (Tree)"
---


## 1) 트리 (Tree)
- 원소들 간에 1:多 관계를 가지는 비선형 자료구조
- 원소들 간에 계층관계를 가지는 계층형 자료구조
- 상위 원소에서 하위 원소로 내려가면서 확장되는 트리(나무) 모양의 구조

![image](https://user-images.githubusercontent.com/55589616/212903104-01dbe40b-9196-44b4-aadb-41e9c19463fd.png)


### 용어 정리
- 노드(Node) : 
    - 트리의 원소
- 루트 노드(Root Node) : 
    - 트리의 시작 노드
- 간선(Edge) : 
    - 노드를 연결하는 선, 부모 노드와 자식 노드를 연결
- 형제 노드(Sibling Node) : 
    - 같은 부모 노드의 자식 노드들
- 조상 노드(Ancestor Node) : 
    - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
- 서브 트리(Subtree) : 
    - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
- 자손 노드 : 
    - 서브 트리에 있는 하위 레벨의 노드들
- 차수(Degree) :
    - 노드의 차수 : 노드에 연결된 자식 노드의 수
    - 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값
    - 단말 노드(리프 노드) : 차수가 0인 노드, 자식 노드가 없는 노드
- 노드의 높이 : 
    - 루트에서 노드에 이르는 간선의 수
- 트리의 높이 : 
    - 트리에 있는 노드의 높이 중에서 가장 큰 값
- 숲(Forest) :
    - 서브 트리의 집합


## 2) 이진 트리
- 트리의 노드 구조를 일정하게 정의하여 트리의 구현과 연산이 쉽도록 정의한 트리
- 이진 트리의 모든 노드는 왼쪽 자식 노드와 오른쪽 자식 노드 만을 가짐
    - 부모 노드와 자식 노드 수와의 관계는 1:2 
    - 공백 노드도 자식 노드로 취급
    - 0 ≤ 노드의 차수 ≤ 2

![image](https://user-images.githubusercontent.com/55589616/213694940-3bbca904-5006-4e90-8315-36bea40d4aa9.png)

- 노드의 왼쪽 자식 노드를 루트로 하는 왼쪽 서브 트리도 이진 트리
- 노드의 오른쪽 자식 노드를 루트로 하는 오른쪽 서브 트리도 이진 트리

![image](https://user-images.githubusercontent.com/55589616/213695156-e3f30fc0-fd14-4939-9399-774e2c1fec2e.png)


### 특성
- n개의 노드를 가진 이진 트리는 항상 (n-1)개의 간선을 가짐
    - 루트를 제외한 (n-1)개의 노드가 부모 노드와 연결되는 한 개의 간선을 가짐
- 이진 트리의 높이가 h가 되려면 한 레벨에 최소한 한 개의 노드가 있어야 함
    - 높이가 𝒉인 이진 트리가 가질 수 있는 노드의 최소 개수는 (𝒉+1)개
- 하나의 노드는 최대 2개의 자식 노드를 가질 수 있음
    - 레벨 i에서 노드의 최대 개수는 2i개
    - 최대 개수는 (𝒉𝟐 + 𝒉 + 𝟏)개가 됨


## 3) 이진트리 배열로 구현
- 높이가 h인 포화 이진 트리의 노드 번호를 배열의 인덱스로 사용
- 인덱스 0번 : 실제로 사용하지 않고 비워둠
- 인덱스 1번 : 루트 저장

![image](https://user-images.githubusercontent.com/55589616/213697142-63373ef1-e0e5-43b0-9fdb-36986865c921.png)


### 색인적 할당
![image](https://user-images.githubusercontent.com/55589616/213697393-d99a3332-3e08-4e12-9cde-4f41f099fc9c.png)


### 순차 자료구조 표현의 단점
- 편향 이진 트리의 경우에 사용하지 않는 배열 원소에 대한 메모리 공간 낭비 발생
- 트리의 원소 삽입/삭제에 대한 배열의 크기 변경 어려움
    - 할당 받은 배열의 크기가 한정되어 있음
    - [삽입 시] 배열의 크기를 늘리는데 복잡하고 시간이 많이 걸림
    - [삭제 시] 배열 원소가 발생하므로 메모리가 낭비


## 4) 이진트리 연결리스트로 구현
-  이진 트리의 모든 노드는 최대 2개의 자식 노드를 가지므로 일정한 구조의 단순 연결 리스트 노드를 사용하여 구현

![image](https://user-images.githubusercontent.com/55589616/213698076-39449f89-0d18-4537-a370-a778554e5270.png)


``` c#
typedef struct treeNode 
{ 
    char data; 
    treeNode *left; 
    treeNode *right; 
}treeNode;
```


### 편향 이진 트리의 표현
- 이진 트리의 연결 자료구조 표현
    - 왼쪽 포인터는 왼쪽 자식 노드를 참조
    - 오른쪽 자식 노드는 없으므로 오른쪽 포인터는 null로 저장
    - 왼쪽 자식 노드가 없는 경우 해당 포인터를 null로 저장

![image](https://user-images.githubusercontent.com/55589616/213698598-3788b333-5724-4c76-83f2-95e8741f88d1.png)


## 5) 이진 트리의 순회
- 계층적 구조로 저장되어있는 트리의 모든 노드를 방문하여 데이터를 처리하는 연산
- 순회를 위해 수행할 수 있는 작업 정의
    - 현재 노드를 방문하여 데이터를 읽는 작업 D
    - 현재 노드의 왼쪽 서브 트리로 이동하는 작업 L 
    - 현재 노드의 오른쪽 서브 트리로 이동하는 작업 R

![image](https://user-images.githubusercontent.com/55589616/214249565-b1f88a69-4bea-4d11-a471-8a869968b750.png)

- 이진 트리 순회의 연산 방법 및 우선순위
    - 계층적 구조로 저장되어있는 트리의 모든 노드를 방문하여 데이터를 처리하는 연산
    - 이진 트리가 순환적으로 정의되어 구성되어 있으므로, 순회작업도 서브 트리에 대해서 순환적으로 반복하여 완성함
    - 왼쪽 서브 트리에 대한 순회를 오른쪽 서브 트리 보다 먼저 수행함


### 전위 순회(Preorder Traversal)
1. 현재 노드 n을 방문하여 처리함 D
2. 현재 노드 n의 왼쪽 서브 트리로 이동함 L
3. 현재 노드 n의 오른쪽 서브 트리로 이동함 R

``` c#
preorder(T)
{
    if (T != null)
    {
        visit T.data;
        preorder(T.left);
        preorder(T.right);
    }
}
```

![image](https://user-images.githubusercontent.com/55589616/214250474-b574ce71-7af8-41e6-97e5-9b13415440e3.png)


### 중위 순회(Inorder Traversal)
1. 현재 노드 n의 왼쪽 서브 트리로 이동함 L
2. 현재 노드 n을 방문하여 처리함 D
3. 현재 노드 n의 오른쪽 서브 트리로 이동함 R

``` c#
inorder(T)
{
    if (T != null)
    {
        inorder(T.left);
        visit T.data;
        inorder(T.right);
    }
}
```

![image](https://user-images.githubusercontent.com/55589616/214253039-77187660-42d5-482f-a6b5-e79de0b965e7.png)


### 후위 순회(Inorder Traversal)
1. 현재 노드 n의 왼쪽 서브 트리로 이동함 L
2. 현재 노드 n의 오른쪽 서브 트리로 이동함 R
3. 현재 노드 n을 방문하여 처리함 D

``` c#
postorder(T)
{
    if (T != null)
    {
        postorder(T.left);
        postorder(T.right);
        visit T.data;
    }
}
```

![image](https://user-images.githubusercontent.com/55589616/214262211-c137bb92-c806-4ae4-9e3b-f8f1dc7e142f.png)

