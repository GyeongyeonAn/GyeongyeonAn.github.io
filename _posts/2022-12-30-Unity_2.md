---
layout: single
title:  "[Unity] 활용 기초 2"
---


## 11) 사원수 (Quaternion)
- 3차원 공간 회전을 표현하는 여러가지 방법중의 하나
- 임의의 카메라 조작이나 키프레임 애니메이션의 보간(interpolation)등에 사용
- 보간 (interpolation)
    - 중간값을 만들어 내는 것
    - 선형 보간
        - Mathf.Lerp()      // 숫자 간의 선형 보간
            - 공식 : (1 - t)a + tb (t: 시간)
        - Vector3.Lerp()    // Vector3간의 선형 보간
        - 끝점의 값이 주어졌을 때 그 사이의 위치값을 추정하기 위하여 직선 거리에 따라 선형적으로 계산하는 방법
    - 구면 선형 보간
        - Mathf.SLerp()      // 숫자 간의 구면 선형 보간
        - Vector3.SLerp()    // Vector3간의 구면 선형 보간
        - 구의 면을 따라서 보간을 계산
- 짐벌락(Gimbal-Lock)을 해결
    - X축을 90도 회전한다고 가정한다면 Y축 또는 Z축이 될 수 있다.
    - 회전축이 겹쳐짐으로 인하여 원하지 않는 계산결과가 나오는 현상
- 계산의 효율이 좋고, 메모리를 적게 사용.


### 사원수의 사용
- 사원수 변환은 4개의 요소로 이루어진 사원수 만을 이용하여 임의의 회전축에 대한 변환을 효율적으로 표현할 수 있다.
- 게임에서 사원수 변환을 적용하려면 최종적으로 행렬의 형태로 변환해서 사용해야 한다. (DirectX)
- 오일러 방식의 회전값 : transform.eulerAngles, transform.localEulerAngles
- 쿼터니언 방식의 회전값 : transform.rotation

![image](https://user-images.githubusercontent.com/55589616/210026336-49f16b4a-30ed-436a-97a8-c8e642187a57.png)

- 벡터를 쿼터니언으로 변환 후 계산하고, 대입하여 사용한다.

``` c#
public class QuaternionExample : MonoBehaviour {

    public GameObject target;

    void Start()
    {
        Vector3 direction = target.transform.position - transform.position;
        
        // Quaternion 회전 방식으로, 짐벌락 현상을 피하며 회전하기
        transform.rotation = Quaternion.Euler(new Vector3(30f, 30f, 30f));
        
        // 방향을 제시하면 그 방향을 쳐다보도록 회전한다.
        transform.rotation = Quaternion.LookRotation(direction);

        Quaternion aRotation = Quaternion.Euler(new Vector3(30f, 0, 0));
        Quaternion bRotation = Quaternion.Euler(new Vector3(60f, 0, 0));
        // 두 개의 값 사이의 중간 값(사잇값)을 구할 수 있다.
        // 결과는 30과 60의 사이인 45도를 회전한다.
        transform.rotation = Quaternion.Lerp(aRotation, bRotation, 0.5f);
        
        Quaternion originalRotation = transform.rotation;
        // originalRotation.eulerAngles는 Quaternion을 Vector3로 변환해준다.
        Vector3 originalRotationVector3 = originalRotation.eulerAngles;

        // 두 Quaternion을 곱하면 값이 더해진다.
        Quaternion targetRotation = aRotation * bRotation;
        // 결과는 x축으로 90도 회전한다.
        transform.rotation = targetRotation;
    }
}
```


## 12) 가시성 판단
- 화면에 보여지는 것과 보여지지 않는것을 판단
- 화면에 보이지 않는 데이터
    - 메시(Mesh)의 뒷면
    - 시야 절두체(MainCamera의 시야)에 포함되지 않는 메시나 면
    - 다른 메시에 가려진 메시나 면
- 가시성 판단은 게임의 속도를 높이기 위해서 사용하는 기술
- 필요없는 데이터를 그리지 않는다.
- 컬링(Culling) : 그려지는(랜더링) 부분을 구분
    - 절두체컬링 : 랜더링 되는 부분 
    - 오큘루전컬링 : 가려진 부분을 랜더링하지 않는 것


### 노멀(normal) 벡터
- 면은 앞뒤가 존재한다.
- 앞뒤를 구분하는 기준은 normal벡터이다.
    - 노멀 벡터가 향하는 방향이 앞면이다.
- 면에 수직인 벡터
- 법선벡터
- 노멀 벡터 3개가 선을 이루어 삼각형을 만들고, 삼각형을 메시가 랜더링한다.
    - 메시는 삼각형으로 이루어지기 때문에, 모서리에 위치한 노멀은 단순히 해당 삼각형의 표면에 수직이라고 볼 수도 있다. 
    - 하지만 노멀 벡터는 실제로 해당 삼각형 전체에 걸쳐 보간된 모서리 사이의 중간 위치 표면에 방향을 지정해 준다. 
    - 만약 세 개의 노멀 모두가 같은 방향을 가리킨다면 이 삼각형 전체에 조명이 균등하게 주어진다.
- 유니티의 모든 게임오브젝트는 정점 3개가 이어져 그려진 여러개의 삼각형으로 이루어져있다.
- 노멀벡터의 개수가 많을 수록, 곡선을 만들 수 있고, 정교한 색과 명암을 구현할 수 있다.

![image](https://user-images.githubusercontent.com/55589616/210029766-faf49b55-4246-4f7d-970c-29725c2a575d.png)


## 13) 게임 오브젝트 이동
- 자신의 위치에서 (10, 10, 10)의 방향으로 이동하기

``` c#
public class GameObjectMove : MonoBehaviour
{
    // 시작 위치   
    private Vector3 startPos;
    // 끝점 위치
    private Vector3 endPos;
    // 목적지 position 벡터
    private Vector3 targetPos;
    // 방향 벡터
    private Vector3 dir;
    // 이동 스피드
    public float moveSpeed;

    private void Start()
    {
        startPos = transform.position;
        endPos.Set(10f, 10f, 10f);
        targetPos = endPos;
        dir = endPos - transform.position;
    }

    private void Update()
    {
        // 목표 지점까지의 거리
        float distance = Vector3.Distance(transform.position, targetPos);
        
        // 목표 지점에 거의 도달했을 때, Start -> End or End -> Start 이동 반복하기
        if (distance < 0.5f)
        {
            // 방향을 바꿔준다.
            dir = -dir;
            // Start -> End
            if (targetPos == startPos)
                targetPos = endPos;
            // End -> Start
            else if (targetPos == endPos)
                targetPos = startPos;
        }
        // 이동 함수
        MovePosition();
    }

    public void MovePosition()
    {
        Vector3 tmp = transform.position;
        tmp.x += dir.normalized.x * Time.deltaTime * moveSpeed;
        tmp.y += dir.normalized.y * Time.deltaTime * moveSpeed;
        tmp.z += dir.normalized.z * Time.deltaTime * moveSpeed;
        transform.position = tmp;
    }
}
```

- 다양한 이동 방법

``` c#
// (x, y, z) 각각 + 연산으로 이동
public void MovePosition()
{
    Vector3 tmp = transform.position;
    tmp.x += dir.normalized.x * Time.deltaTime * moveSpeed;
    tmp.y += dir.normalized.y * Time.deltaTime * moveSpeed;
    tmp.z += dir.normalized.z * Time.deltaTime * moveSpeed;
    transform.position = tmp;
}

// Translate 함수로 이동
public void TranslateMove()
{
    Vector3 delta = dir.normalized * Time.deltaTime * moveSpeed;
    transform.Translate(delta);
}

// MoveTowards 함수로 이동
// 1. 목표지점까지 정확하게 이동할 수 있는 함수 (소수점까지 맞춰준다)
// 2. 목표지점까지 도달했는지 조건을 체크하지 않아도 된다.
// 3. 방향벡터가 필요 없다.
public void MoveTowardMove()
{
    float delta = Time.deltaTime * moveSpeed;
    transform.position = Vector3.MoveTowards(transform.position, endPos, delta);
}
```


## 14) 발사체 구현
- 유니티는 랜더링 시스템과 물리 시스템이 구분되어져 있다.
    - 랜더링 시스템 : 눈에 보여지는 것을 다루는 시스템
    - 물리 시스템 : 물리량을 다루는 시스템
    - 생각해야 할 점 : 빠른 물체의 이동속도를 갖는 발사체와 같은 충돌을 효과적으로 구현하기 위한 방법
- 특정 목표지점 또는 방향으로 날아가는 물체 (힘, 속도, 위치계산)
- 구현 방법 : Physics 클래스를 이용
    - 물체의 움직임을 현실적으로 표현하기 위한 물리 시스템.
    - 구성요소
        - RigidBody(강체) : 질량(mass), 저항(Drag), 중력(Gravity)
        - Collider : 물리재질, 마찰(Friction), 반동(Bounciness)


### RigidBody 컴포넌트
![image](https://user-images.githubusercontent.com/55589616/210294983-31c2bf9c-7a3b-4aad-b60a-9e85f9d35d75.png)
![image](https://user-images.githubusercontent.com/55589616/210295024-5042db1c-4416-4004-a388-f0c28613ab08.png)


### Collider 컴포넌트
- Shpere Colider가 충돌 연산량이 제일 적다. (두 원의 반지름 사이의 거리 < 두 원의 반지름의 합)
- Collider의 충돌을 감지하기 위해서는 rigidbody가 필요하다.


![image](https://user-images.githubusercontent.com/55589616/210295081-415f5875-a66a-4668-ba95-5d30e91c905c.png)


## 15) Random() 함수
- Random.Range(float a, float b) : a ~ b 범위의 랜덤 값 반환
- Random.Range(int a, int b) : a ~ b-1 범위의 랜덤 값 반환

``` c#
public class PrimitiveInstance : MonoBehaviour
{
    private void Update()
    {
        // 기본 도형 생성하기
        if (Input.GetMouseButton(0))
        {
            GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
            
            obj.name = "Test";
            // 생성한 기본 도형의 위치를 (-10~10, -3~3, -3~5)의 범위에서 생성하시오.
            // 실수를 넣은 경우 : Random.Range(-10f, 10f) = -10 ~ 10
            // 정수를 넣은 경우 : Random.Range(-10, 10) = -10 ~ 9
            obj.transform.position = new Vector3(Random.Range(-10f, 10f), Random.Range(-3f, 3f), Random.Range(-3f, 5f));

            // 3초 후 오브젝트 파괴
            GameObject.Destroy(obj, 3f);
        }
    }
}
```


## 16) Player 이동 구현
- 키를 눌렀을 때를 체크하는 함수
    - Input.GetKeyDown() : 키를 누른 시점에 참을 반환
    - Input.GetKeyUp() : 키를 누른 상태를 벗어난 시점에 참을 반환
    - Input.GetKey() : 키를 누르는 중인 상태에 참을 반환

``` c#
public class InputExample : MonoBehaviour
{
    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.LeftArrow))
        {
            Debug.Log("LeftArrow Down");
        }
        if (Input.GetKeyUp(KeyCode.LeftArrow))
        {
            Debug.Log("LeftArrow Up");
        }
        if (Input.GetKey(KeyCode.A))
        {
            Debug.Log("A키를 누르고 있는 동안");
        }
    }

}
```

- 플레이어의 W A S D 이동
    - Input.GetAxis(string name)
        - 설정된 버튼의 입력을 받으면 해당하는 float 값 반환
        - "Project Settings -> Input Manager"에서 입력 설정을 확인할 수 있다.
        - 1f ~ 1f 의 값을 반환한다.
        - 가속하는 느낌의 부드러운 이동이 필요한경우 사용한다
    - Input.GetAxisRaw(string name)
        - 설정된 버튼의 입력을 받으면 해당하는 float 값 반환
        - "Project Settings -> Input Manager"에서 입력 설정을 확인할 수 있다.
        - 1f , 0f, 1f 의 값을 반환한다. 
        - 즉각적인 반응이 필요할때 사용한다.

``` c#
public class InputExample : MonoBehaviour
{
    // 변수 선언 시점에 바로 초기화 하지 말자 : 선언부의 호출 수가 늘어나는 것은 좋지 않은 방법이다.
    // public float moveSpeed = 5f;
    public float moveSpeed;
    private Vector3 movement

    private void Start()
    {
        moveSpeed = 5f;
        movement = new Vector3();
    }

    private void Update()
    {
        // A, D, left, right 버튼 입력에 따라 1f ~ 1f의 값 반환
        movement.x = Input.GetAxis("Horizontal");
        // W, S, up, down 버튼 입력에 따라 1f ~ 1f의 값 반환
        movement.y = Input.GetAxis("Vertical");

        // A, D, left, right 버튼 입력에 따라 1f, 0f, 1f의 값 반환
        movement.x = Input.GetAxisRaw("Horizontal");
        // W, S, up, down 버튼 입력에 따라 1f, 0f, 1f의 값 반환
        movement.y = Input.GetAxisRaw("Vertical");

        // 정규화를 하는 이유
        // - 대각선 버튼(W, A를 동시에 클릭)을 클릭하는 경우 더해지는 값이 커져서 더 빠른 속도로 이동한다.
        // - 정규화를 하게 되면 이러한 속도를 일반적인 속도로 맞춰줄 수 있게 된다.
        transform.Translate(movement.normalized * Time.deltaTime * moveSpeed);
    }
}
```

## 17) Ray 활용기초
- Physics.Raycast는 직선을 씬에 투영하여 대상에 적중되면 true를 리턴하는 물리 함수다.
- Ray 변수
- RaycastHit 변수
- Raycast 함수 
- RaycastAll 함수
- RaycastNonAlloc 함수

### Ray 구조체 사용법
- Ray는 직선의 시작점(origin)과 방향(direction)을 가지고 있는 단순한 구조체다.
- 시작점(origin)은 Vector3 타입의 월드 포지션이며 방향(direction)은 직선의 방향을 나타낼 Vector3 타입의 법선 벡터다.
- Ray는 사용할 때 마다 업데이트 되어야 한다.
    - Ray의 시작점과 방향이 매 프레임마다 달라지는 경우 Ray도 매 프레임 마다 갱신되어야 한다.


``` c#
private void update()
{
    // Creates a Ray from this object, moving forward
    Ray objectForwardRay = new Ray(transform.position, transform.forward);

    // Creates a Ray from the center of the viewport
    // 아래에서 0.5f 값은 뷰포트의 중간값을 나타낸다.
    Ray cameraCenterRay = Camera.main.ViewportPointToRay(new Vector3 (0.5f, 0.5f, 0));

    // Creates a Ray from the mouse position
    Ray mousePointRay = Camera.main.ScreenPointToRay(Input.mousePosition);
}
```


### RaycastHit 구조체 사용법
- RaycastHit은 객체와 Ray의 충돌에 대한 결과 정보를 저장하는 구조체다. 
- Raycast 함수의 out 파라미터로 사용된다.
- 월드에서 Raycasting의 Hit가 발생한 위치, Ray가 충돌한 물체, Ray의 원점에서 얼마나 떨어져있는지 등의 정보를 저장하여 돌려준다.

``` c#
private void update()
{
    // Container for hit data
    RaycastHit hitData;

    // Gets hit position
    Vector3 hitPosition = hitData.point;

    // Gets 원점에서 충돌 지점까지의 거리
    float hitDistance = hitData.distance;

    // Reads the Collider tag
    string tag = hitData.collider.tag;

    // Gets a Game Object reference from its Transform
    GameObject hitObject = hitData.transform.gameObject;
}
```


### Raycast 함수 사용법
- Ray가 씬의 다른 객체와 충돌하는지 여부를 알 수 있으며 충돌할 경우 충돌 정보를 RaycastHit 변수에 저장할 수 있다.
- Physics.Raycast 함수의 리턴 타입은 bool이다. 
    - Ray에 어떠한 오브젝트라도 걸리면 true를 리턴한다.
- 추가 디폴트 인자로 ray의 충돌 탐지 거리 제한, 특정 레이어 또는 트리거 콜라이더 무시하기 등의 제약사항을 추가할 수 있다. 
    - 이러한 세팅들은 어떤 오버로드 된 레이케스트 함수를 사용하느냐에 따라 달라진다.

``` c#
void Update()
{
    Ray ray = new Ray(transform.position, transform.forward);
    RaycastHit hitData;

    if (Physics.Raycast(ray, out hitData))
    {
        // The Ray hit something!
    }
}
```

- 추가 디폴트 인자 사용

``` c#
// Raycast할 Layer 선택
public LayerMask layerMask;

void Update()
{
    Ray ray = new Ray(transform.position, transform.forward);
    RaycastHit hitData;
    
    if (Physics.Raycast(ray, out hitData, 10, layerMask, QueryTriggerInteraction.Ignore))
    {
        // The Ray hit something less than 10 Units away,
        // It was on the a certain Layer
        // But it wasn't a Trigger Collider
    }
}
```


### LayerMask를 사용할 때 레이어 번호를 직접 입력하는 방법
- 우리는 때로 Layer Mask를 동적으로 지정해야할 때도 있다.
- 유니티에서는 총 32개의 Layer를 지원하며 각 Layer를 구분하기 위해 32bit Bit Mask를 사용한다. 
- Layer는 0부터 시작하며 31이 마지막 Layer번호다.

![image](https://user-images.githubusercontent.com/55589616/212613547-74152c05-5428-4f66-b7f1-2e748056d504.png)

- 레이어를 번호로 선택할때는 쉬프트 연산을 사용하는 것이 효과적이다.
- 9번 레이어만 선택하여 Raycast 체크하기

``` c#
void Update()
{
    Ray ray = new Ray(transform.position, transform.forward);
    
    if (Physics.Raycast(ray, 10, 1<<9))
    {
        // Layer 9 was hit!
    }
}
```

- 9번 레이어만 제외하고 모든 레이어 Raycast 체크하기

``` c#
void Update()
{
    Ray ray = new Ray(transform.position, transform.forward);

    if (Physics.Raycast(ray, 10, ~(1<<9)))
    {
        Debug.Log("something else was hit");
    }
}
```


### 레이어 이름과 레이어 번호의 상호작용
- LayerMask.NameToLayer(string layerName) : 레이어의 문자열 이름을 입력으로 레이어 번호를 반환한다.
- LayerMask.LayerToName(int layerNumber) : 레이어의 번호를 입력으로 레이어 문자열 이름을 반환한다.

``` c#
int layerNum = LayerMask.NameToLayer("UI");
Debug.Log(layerNum); // 5
```

- 쉬프트 연산자를 사용해야 한다는 것을 주의하자

``` c#
Ray ray = new Ray(transform.position, transform.forward);
int layerNum = LayerMask.NameToLayer("UI");

if (Physics.Raycast(ray, 10, 1<<layerNum))
{
    Debug.Log("something else was hit");
}
```

### QueryTriggerInteraction
- QueryTriggerInteraction 파라미터는 아래 세 가지 중 하나의 값을 가질 수 있다.
    - Ignore - 트리거 콜라이더의 충돌을 무시한다.
    - Collider - 트리거 콜라이더의 충돌을 허용한다.
    - UseGlobal - Physics 옵션에 정의된 기본 값을 따른다


### RaycastAll 함수 사용법
- Raycast 함수에서 단 하나의 객체에 대한 충돌 정보만 반환하는 대신 RaycastHit 구조체 배열을 이용해 여러 개체에 대한 충돌 정보들을 반환한다. 

``` c#
public RaycastHit[] hits;

void Update()
{
    Ray ray = new Ray(transform.position, transform.forward);
    hits = Physics.RaycastAll(ray);
}
```

- Ray의 경로에 있던 모든 객체들을 파괴하는데 사용 될 수도 있다.

``` c#
public class CameraRay : MonoBehaviour
{
    public RaycastHit[] hits;

    void Update()
    {
       if(Input.GetMouseButtonDown(0))
        {
            FireLaser();
        }
    }

    void FireLaser()
    {
        Ray ray = new Ray(transform.position, transform.forward);
        hits = Physics.RaycastAll(ray);

        foreach(RaycastHit obj in hits)
        {
            Destroy(obj.transform.gameObject);
        }
    }
}
```


### RaycastAll의 문제
- RaycastAll은 여러 충돌체를 감지 할 수는 잇지만 정의되지 않은 순서로 검색한다. 
- 물체를 통과한 레이저의 시작점과 가까이 있는 순서대로 배열에 들어갈것 같지만 실제 결과값은 예측 할 수 없는 순서로 저장된다.
- 순서가 중요하다면 아래와 같이 거리에 따라 배열을 정렬하는 방법도 있다.

``` c#
void FireLaser()
{
    RaycastHit[] hits;
    Ray ray = new Ray(transform.position, transform.forward);
    hits = Physics.RaycastAll(ray);

    // Sorts the Raycast results by distance
    Array.Sort(hits, (RaycastHit x, RaycastHit y) => x.distance.CompareTo(y.distance));
}
```


### RaycastNonAlloc 함수 사용법
- 외부에서 이미 생성된 배열을 out 파라메터로 재사용 할 수 있어 가비지(garbage)의 발생을 줄인다.
- 충돌한 객체의 개수를 리턴하지만 그 수는 인자로 넘겨진 배열의 길이 보다는 크지 않다. 
- 실제 반환된 충돌된 객체의 개수를 알면 리턴된 배열이 가득 차지 않았을 때 빈 요소들을 참조하는 것을 방지할 수 있다.
- RaycastNonAlloc도 정의되지 않은 순서로 충돌 정보 배열을 리턴한다.

``` c#
void FireLaser()
{
    RaycastHit[] results = new RaycastHit[10];

    void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            FireLaser();
        }
    }

    void FireLaser()
    {
        Ray ray = Camera.main.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0));
        int hits = Physics.RaycastNonAlloc(ray, results);

        for(int i=0; i < hits; i++)
        {
            Destroy(results[i].transform.gameObject);
        }
    }
}