---
layout: single
title:  "[Unity] 활용 기초 2"
---


## 11) 사원수 (Quaternion)
- 3차원 공간 회전을 표현하는 여러가지 방법중의 하나
- 임의의 카메라 조작이나 키프레임 애니메이션의 보간(interpolation)등에 사용
- 보간 (interpolation)
    - 중간값을 만들어 내는 것
    - 선형 보간
        - Mathf.Lerp()      // 숫자 간의 선형 보간
        - Vector3.Lerp()    // Vector3간의 선형 보간
        - 끝점의 값이 주어졌을 때 그 사이의 위치값을 추정하기 위하여 직선 거리에 따라 선형적으로 계산하는 방법
    - 구면선형 보간
        - Mathf.SLerp()      // 숫자 간의 선형 보간
        - Vector3.SLerp()    // Vector3간의 선형 보간
        - 구의 면을 따라서 보간을 계산
- 짐벌락(Gimbal-Lock)을 해결
    - X축을 90도 회전한다고 가정한다면 Y축 또는 Z축이 될 수 있다.
    - 회전축이 겹쳐짐으로 인하여 원하지 않는 계산결과가 나오는 현상
- 계산의 효율이 좋고, 메모리를 적게 사용.


### 사원수의 사용
- 사원수 변환은 4개의 요소로 이루어진 사원수 만을 이용하여 임의의 회전축에 대한 변환을 효율적으로 표현할 수 있다.
- 게임에서 사원수 변환을 적용하려면 최종적으로 행렬의 형태로 변환해서 사용해야 한다. (DirectX)
- 오일러 방식의 회전값 : transform.eulerAngles, transform.localEulerAngles
- 쿼터니언 방식의 회전값 : transform.rotation

![image](https://user-images.githubusercontent.com/55589616/210026336-49f16b4a-30ed-436a-97a8-c8e642187a57.png)

- 벡터를 쿼터니언으로 변환 후 계산하고, 대입하여 사용한다.

``` c#
public class QuaternionExample : MonoBehaviour {
    
    public GameObject target;

    void Start()
    {
        Vector3 direction = target.transform.position - transform.position;
        
        // Quaternion 회전 방식으로, 짐벌락 현상을 피하며 회전하기
        transform.rotation = Quaternion.Euler(new Vector3(30f, 30f, 30f));
        
        // 방향을 제시하면 그 방향을 쳐다보도록 회전한다.
        transform.rotation = Quaternion.LookRotation(direction);

        Quaternion aRotation = Quaternion.Euler(new Vector3(30f, 0, 0));
        Quaternion bRotation = Quaternion.Euler(new Vector3(60f, 0, 0));
        // 두 개의 값 사이의 중간 값(사잇값)을 구할 수 있다.
        // 결과는 30과 60의 사이인 45도를 회전한다.
        transform.rotation = Quaternion.Lerp(aRotation, bRotation, 0.5f);
        
        Quaternion originalRotation = transform.rotation;
        // originalRotation.eulerAngles는 Quaternion을 Vector3로 변환해준다.
        Vector3 originalRotationVector3 = originalRotation.eulerAngles;

        // 두 Quaternion을 곱하면 값이 더해진다.
        Quaternion targetRotation = aRotation * bRotation;
        // 결과는 x축으로 90도 회전한다.
        transform.rotation = targetRotation;
    }
}
```


## 12) 가시성 판단
- 화면에 보여지는 것과 보여지지 않는것을 판단
- 화면에 보이지 않는 데이터
    - 메시(Mesh)의 뒷면
    - 시야 절두체(MainCamera의 시야)에 포함되지 않는 메시나 면
    - 다른 메시에 가려진 메시나 면
- 가시성 판단은 게임의 속도를 높이기 위해서 사용하는 기술
- 필요없는 데이터를 그리지 않는다.
- 컬링(Culling) : 그려지는(랜더링) 부분을 구분
    - 절두체컬링 : 랜더링 되는 부분 
    - 오큘루전컬링 : 가려진 부분을 랜더링하지 않는 것


### 노멀(normal) 벡터
- 면은 앞뒤가 존재한다.
- 앞뒤를 구분하는 기준은 normal벡터이다.
    - 노멀 벡터가 향하는 방향이 앞면이다.
- 면에 수직인 벡터
- 법선벡터
- 노멀 벡터 3개가 선을 이루어 삼각형을 만들고, 삼각형을 메시가 랜더링한다.
- 유니티의 모든 게임오브젝트는 노멀벡터 3개가 있는 여러개의 삼각형으로 이루어져있다.
- 노멀벡터의 개수가 많을 수록, 곡선을 만들 수 있고, 정교한 색과 명암을 구현할 수 있다.


![image](https://user-images.githubusercontent.com/55589616/210029766-faf49b55-4246-4f7d-970c-29725c2a575d.png)


## 13) 게임 오브젝트 이동
- 자신의 위치에서 (10, 10, 10)의 방향으로 이동하기


``` c#
public class GameObjectMove : MonoBehaviour
{
    // 시작 위치   
    private Vector3 startPos;
    // 끝점 위치
    private Vector3 endPos;
    // 목적지 position 벡터
    private Vector3 targetPos;
    // 방향 벡터
    private Vector3 dir;
    // 이동 스피드
    public float moveSpeed;

    private void Start()
    {
        startPos = transform.position;
        endPos.Set(10f, 10f, 10f);
        targetPos = endPos;
        dir = endPos - transform.position;
    }

    private void Update()
    {
        // 목표 지점까지의 거리
        float distance = Vector3.Distance(transform.position, targetPos);
        
        // 목표 지점에 거의 도달했을 때, Start -> End or End -> Start 이동 반복하기
        if (distance < 0.5f)
        {
            // 방향을 바꿔준다.
            dir = -dir;
            // Start -> End
            if (targetPos == startPos)
                targetPos = endPos;
            // End -> Start
            else if (targetPos == endPos)
                targetPos = startPos;
        }
        // 이동 함수
        MovePosition();
    }

    public void MovePosition()
    {
        Vector3 tmp = transform.position;
        tmp.x += dir.normalized.x * Time.deltaTime * moveSpeed;
        tmp.y += dir.normalized.y * Time.deltaTime * moveSpeed;
        tmp.z += dir.normalized.z * Time.deltaTime * moveSpeed;
        transform.position = tmp;
    }
}
```


- 다양한 이동 방법


``` c#
// (x, y, z) 각각 + 연산으로 이동
public void MovePosition()
{
    Vector3 tmp = transform.position;
    tmp.x += dir.normalized.x * Time.deltaTime * moveSpeed;
    tmp.y += dir.normalized.y * Time.deltaTime * moveSpeed;
    tmp.z += dir.normalized.z * Time.deltaTime * moveSpeed;
    transform.position = tmp;
}

// Translate 함수로 이동
public void TranslateMove()
{
    Vector3 delta = dir.normalized * Time.deltaTime * moveSpeed;
    transform.Translate(delta);
}

// MoveTowards 함수로 이동
// 1. 목표지점까지 정확하게 이동할 수 있는 함수 (소수점까지 맞춰준다)
// 2. 목표지점까지 도달했는지 조건을 체크하지 않아도 된다.
// 3. 방향벡터가 필요 없다.
public void MoveTowardMove()
{
    float delta = Time.deltaTime * moveSpeed;
    transform.position = Vector3.MoveTowards(transform.position, endPos, delta);
}
```

## 14) 발사체 구현
- 유니티는 랜더링 시스템과 물리 시스템이 구분되어져 있다.
    - 랜더링 시스템 : 눈에 보여지는 것을 다루는 시스템
    - 물리 시스템 : 물리량을 다루는 시스템
    - 생각해야 할 점 : 빠른 물체의 이동속도를 갖는 발사체와 같은 충돌을 효과적으로 구현하기 위한 방법
- 특정 목표지점 또는 방향으로 날아가는 물체 (힘, 속도, 위치계산)
- 구현 방법 : Physics 클래스를 이용
    - 물체의 움직임을 현실적으로 표현하기 위한 물리 시스템.
    - 구성요소
        - RigidBody(강체) : 질량(mass), 저항(Drag), 중력(Gravity)
        - Collider : 물리재질, 마찰(Friction), 반동(Bounciness)


### RigidBody 컴포넌트
![image](https://user-images.githubusercontent.com/55589616/210294983-31c2bf9c-7a3b-4aad-b60a-9e85f9d35d75.png)
![image](https://user-images.githubusercontent.com/55589616/210295024-5042db1c-4416-4004-a388-f0c28613ab08.png)


### Collider 컴포넌트
- Shpere Colider가 충돌 연산량이 제일 적다. (두 원의 반지름 사이의 거리 < 두 원의 반지름의 합)
- Collider의 충돌을 감지하기 위해서는 rigidbody가 필요하다.


![image](https://user-images.githubusercontent.com/55589616/210295081-415f5875-a66a-4668-ba95-5d30e91c905c.png)


## 15) Primitive Instance
``` c#
public class PrimitiveInstance : MonoBehaviour
{
    private void Awake()
    {
        Debug.Log("첫번째");
    }

    // GameObject가 활성화되는 경우 실행
    private void OnEnable()
    {
        Debug.Log("두번째");
    }

    // GameObject가 비활성화되는 경우 실행
    private void OnDisable()
    {
        Debug.Log("OnDisable");
    }

    private void Start()
    {
        Debug.Log("세번째");
    }

    private void Update()
    {
        // 기본 도형 생성하기
        if (Input.GetMouseButton(0))
        {
            GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
            obj.name = "Test";
            // 생성한 기본 도형의 위치를 (-10~10, -3~3, -3~5)의 범위에서 생성하시오.
            // Random.Range의 두번째 파라미터는 실수를 넣는 경우 그 숫자를 포함한다.
            // Random.Range(-10f, 10f) = -10 ~ 10
            // 정수를 넣는 경우는 포함하지 않는다.
            // Random.Range(-10, 10) = -10 ~ 9
            obj.transform.position = new Vector3(Random.Range(-10f, 10f), Random.Range(-3f, 3f), Random.Range(-3f, 5f));

            // 3초 후 오브젝트 파괴
            GameObject.Destroy(obj, 3f);

            // GameObject 비활성화
            obj.SetActive(false);

            // 컴포넌트 비활성화
            // 예) 생성한 게임오브젝의 BoxCollider를 비활성화
            BoxCollider boxCollider = obj.GetComponent<BoxCollider>();
            boxCollider.enabled = false;
        }
    }
}
```
