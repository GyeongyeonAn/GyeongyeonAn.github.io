---
layout: single
title:  "[Unity] 활용 기초"
---


## 1) 가비지 콜렉터 (Garbage Collector)
- 가비지 컬렉터란 사용하지 않는 메모리를 자동적으로 회수하는 .Net서비스다.
    - 게임오브젝트에서 컴포넌트를 가져오고자 한다면 GetComponent() 메서드를 사용하고 
    - 추가하고자 한다면 AddComponent() 메서드를 사용한다. 
    - 이러한 메서드는 가비지콜랙터 (Garbage Collector)에 의해 수거되는 일정양의 가비지를 남긴다.
- 가비지 수집은 시스템 백그라운드에서 상당한 CPU자원을 소모하므로 실행 시 일시 멈춤 현상이 발생할 수 있다. 
- 힙(Heap)메모리 해제를 수동으로 하는 상황이 아니므로 가급적 가비지를 발생시키지 말아야 한다. 
- 여러 번 호출하기 보다는 실행 시 한번 호출하는 것이 효율적이다.
- 즉, GetComponent의 사용을 최대한 줄이고, AddComponent는 괜찮다.


## 2) 게임 오브젝트 (GameObject)
- Unity에서 제공하거나 직접 만든 모든 오브젝트의 자료형을 GameObject라고 한다.
- GameObject : 클래스(자료형)의 개념
- gameObject : GameObject에 속해있는 컴포넌트에 접근하기 위한 인스턴스
    - 인스턴스 : 하나의 클래스에서 생성된 객체


### 게임 오브젝트 검색
- 검색은 항상 많은 비용이 예상 되므로 사용 할 때는 주의를 기울여야 한다. 
- Hierarchy에 올려진 게임오브젝트 개수가 많을 때에는 매 프레임 마다 검색하는 것이 효율적이지 않으므로 검색하고자 하는 오브젝트들을 처음 한번 검색하여 저장 후 시작하는 것을 추천한다.
- 다양한 검색 방법
    - Find : GameObject를 이름으로 검색할 할 때, 사용한다. 
    - FindWithTag : GameObject를 Tag로 검색할 때, 사용한다. 
    - FindGameObjectsWithTag : 복수개의 GameObject를 Tag로 검색할 때, 사용한다.
    - FindObjectOfType : Script의 Type으로 검색할 할 때, 사용한다. 
        - **Type으로 검색할 경우 스크립트의 함수 호출시 GetComponent를 호출하지 않는 장점이 있다.**
        - **Garbage 수거를 줄일 수 있다.** 


``` c#
public class ObjectFindScript : MonoBehaviour {
{
    // 이름으로 찾기
    GameObject obj = GameObject.Find(string strname);
    // Tag로 찾기
    GameObject obj = GameObject.FindWithTag(string strTag); 
    // Tag로 여러개를 찾기
    GameObject [] obj = GameObject.FindGameObjectsWithTag(string strTag); 
    // type으로 찾기
    // GetComponent를 호출하지 않음으로 가비지 남김을 줄일 수 있다.
    MyScript obj = (MyScript)FindObjectOfType(typeof(MyScript));
}
```


## 3) Log 메서드의 종류
- DeBug.Log : Console뷰에 메세지 출력
- DeBug.LogWarning : Console뷰에 경고 메세지 출력
- DeBug.LogError : Console뷰에 에러 메세지를 출력


## 4) Log 게임 리소스와 프리펩
- 게임 리소스는 게임에서 사용하는 자원을 일컫는 말이다. 
- 게임 리소스를 사용하기 위해서 프리팹(Prefab)이라는 게임 오브젝트를 사용해야 한다. (반드시 프리팹 이어야만 리소스로 사용가능 한 것은 아니다.)
- 리소스 파일은 저장된 장소에 따라서 읽어 오는 방식이 다르다. (이미 약속된 장소라면 간단히 읽어 올 수 있다.) 
- Unity는 Resources 폴더라는 이름의 특정 폴더에서 리소스를 읽어 올 수 있도록 하였다. 
    - Resources 폴더는 Assets 폴더 하위에서만 존재 해야 한다. 
    - 자동으로 생성해주는 폴더가 아니므로 직접 생성한다.
- Resources 폴더가 아닌 곳에 데이터를 보관하고 읽어 오고 싶다면 AssetBundle 이라는 데이터를 제작하여 읽어와야 하는 번거로움이 있다.
- FBX파일 : 프리팹(Prefab)의 원본 파일로 그래픽 저작도구(3DS MAX 등)로 제작한 캐릭터, 배경 등의 리소스 파일이다. 


## 5) 리소스 불러오기
- Resources.Load 메서드는 Resources 폴더안에 있는 리소스를 메모리 상에 로드 하지만 화면에 보여지는 것은 아니다. 
- 화면에 보여주기 위해서는 Intstantiate 메서드로 인스턴스(Instance)를 생성한다.
- 아래 2번째 코드는 리소스 폴더의 전체 프리팹을 로드 할 경우를 보여준다.


``` c#
public class ResourceLoad : MonoBehaviour {

    private GameObject Ammo_obj;
    private GameObject Cargo_obj;
    void Start()
    {
        // “Resources/Prefab폴더의 AMMO GameObject 로드
        GameObject tmp = Resources.Load<GameObject>("Prefab/AMMO");

        // Resources 폴더의 Cargo GameObject 로드
        GameObject tmp_1 = Resources.Load<GameObject>("Cargo");
        
        // 같은 결과 다른 표현들
        // GameObject tmp = (GameObject)Resources.Load("Prefab/AMMO");
        // GameObject tmp = Resources.Load("Prefab/AMMO") as GameObject;

        // 화면에 obj 인스턴스 생성
        Ammo_obj = (GameObject)Instantiate(tmp);
        Cargo_obj = (GameObject)Instantiate(tmp_1);
    }
}
```


``` c#
public class ResourcesFolderLoad : MonoBehaviour {

    private GameObject [] HPBOX_obj;
    void Start()
    {
        // “Resources/Prefab폴더의 모든 게임오브젝트 로드
        GameObject [] tmp = Resources.LoadAll<GameObject>("Prefab");

        // 프리팹 개수 만큼 배열 할당.
        HPBOX_obj = new GameObject[tmp.Length];

        // 화면에 Prefab폴더안의 모든 프리팹 출력
        for (int i = 0; i < tmp.Length; i++)
        {
            HPBOX_obj[i] = (GameObject)Instantiate(tmp[i]);
            // 인스턴스 게임오브젝트 이름 변경
            HPBOX_obj[i].name = "HPBOX_" + i.ToString();
        }
    }
}
```


## 6) 이벤트 함수
- Awake()
    - GameObject가 유니티 내부에서 Instantiate될 때, **활성화 상태**일 경우 호출된다. 
    - 단, MonoBehaviour를 상속 받은 스크립트 컴포넌트가 활성/비활성에 상관 없이 호출된다.
    - **하위 순서인 OnEnable(), Start(), Update()는 컴포넌트가 활성화 되어야만 호출된다.**
- OnEnable()
    - 게임 시작 이후, 첫 프레임 시작 전, GameObject가 활성화 될 때 호출되는 함수
- Start()
    - 게임 시작 이후, 첫 프레임 시작 전, Update 직전에 단 한번 호출되는 함수
- FixedUpdate()
    - 물리 갱신용
    - 게임 오브젝트가 Enable 되어 있는 동안, 설정된 고정 시간 주기로 실행되는 함수
    - 고정 시간 주기 설정법
        - Edit -> Project Setting -> Time -> Fixed Timestep의 값을 조정한다. (작아질 수록 빨라짐)
- Update()
    - 랜더링 갱신용
    - 게임 오브젝트가 Enable 되어 있는 동안 매 프레임마다 반복 호출되는 함수
    - 속도가 느린 기기에 실행해서 게임의 프레임이 속도가 떨어지는 상황이 오면 호출 빈도가 줄어들 수 있다.
    - 랜더링과 물리 중 속도가 빠른 것은 랜더링인 Update함수다. (시간 제어는 속도가 빠른 곳에서 하는 것이 좋다)
- LateUpdate()
    - 가장 늦게 갱신해야하는 내용
    - Update함수중 가장 마지막에 호출되는 Update함수
    - 주로 카메라에 해당(카메라는 캐릭터, 배경, 몬스터 등등 게임세계가 모두 갱신된 후 갱신해야한다)
- OnDisable() : 
    - 게임 오브젝트가 비활성화 될 때(꺼질때) 마다 호출되는 함수
    - 호출 시에는 Update 가 대기 상태가 되며 정지된다.
    - 다시 활성화 할 경우, OnEnable 부터 실행 된다.
- OnApplicationQuit()
    - Application 종료 시 호출 되는 함수


![image](https://user-images.githubusercontent.com/55589616/209093883-f8650386-6c7d-4701-9dfe-cb95a2a6c320.png)


## 7) 시간 제어
- Time.deltaTime
    - 마지막 프레임을 완료하는 데 걸린 시간 (초)
    - 다음 업데이트 호출까지의 간격
    - 컴퓨터의 성능에 따라 값이 다르다.
    - 이 기능을 사용하면 게임 프레임 속도를 독립적으로 설정할 수 있다.
- Time.fixedDeltaTime
    -  다음 FixedUpdate함수 호출까지의 간격
- Time.time 
    - 게임시작 후 진행된 시간 (초)
    - Start함수에서  Debug.Log(Time.time) 사용하면  0이 출력되고 Update함수에서는 값이 계속 증가할 것이다.
- Time.timeScale 
    - 시간이 지나가는 스케일
    - 슬로우 모션 효과에 사용할 수 있다.
        - Time.timeScale 이 1이라면 원래의 진행 속도를 의미하며 0.5라면 절반의 진행 속도를 의미한다.
        - 보스 몬스터를 처치 하였을 경우 보상을 받는 상황일 때, Time.timeScale값을 조절하여 원하는 연출을 할 수 있다.


``` c#
public class TimerTest : MonoBehaviour {
    // public 이므로 유니티 인스펙터 창에서 fSpeed값을 입력 할 수 있다.
    public float fSpeed = 10f;
    float curTime;
    float fSum = 0;

    void Start () 
    {
        Debug.Log (Time.time);
        curTime = Time.time;
    }

    void PerSecond()
    {
        // 1초당 한번씩 출력 (Time.time을 이용 )
        if ( Time.time - curTime >= 1.0f )
        {
            //Debug.Log("1초당 한번 출력 : time이용");
            curTime = Time.time;
        }

        // 1초당 한번씩 deltatTime을 이용
        fSum += Time.deltaTime;
        if (fSum - 1f >= 0)
        {
            fSum = 0f;
            //Debug.Log("1초당 한번 출력 : deltaTime이용");
        }
    }

    void Update () 
    {
        // deltaTime에 따른 이동속도 
        float translation = Time.deltaTime * fSpeed;
        transform.Translate(0, 0, translation);

        Debug.Log(Time.time);
        PerSecond();
    }
}
```


### 1초 간격 정밀하게 구현하기
- **코루틴을 사용하여 시간을 제어하는 방법도 있지만, Update에서 시간을 제어하는 방법을 택하는 것이 좋다.**
- 시간 제어를 정밀하게 구현해야하는 이유
    - 랜더링은 1초가 늦어져도 큰 문제는 없겠지만, 데이터는 무결성을 만족해야한다.
    - 1초마다의 데이터의 변화는 중요하고 예민한 문제이다.
    - 자체 엔진을 사용하는 기업들은 랜더링과 데이터를 따로 제어할 수 있는데, 
    - Unity에서는 Update라는 한 프레임 단위에서 함께 관리하기 때문에, 시간제어가 중요하다.


``` c#
public class UpdateExample : MonoBehaviour
{
    float elapsed;
    float oldTime;

    void Start()
    {
        elapsed = 0;
        oldTime = Time.time;
    }

    void Update()
    {
        // 1초 간격 안정적으로 구현하기
        elapsed = Time.time - oldTime;
        if(elapsed >= 1f)
        {
            // 1초마다 실행할 기능을 넣어준다.
            // .............................
            // 소주점까지 고려한다면 elapsed - 1f 값을 더해준다.
            oldTime = Time.time + elapsed - 1f;
        }
    }
}
```


## 8) 벡터
- 벡터
    - 크기와 방향을 갖는다
    - 방향은 부호를 의미
    - 변위, 속도, 가속도
- 스칼라
    - 크기만 갖는다
    - 절대값으로 계산
    - 거리, 속력, 가속력
    - 벡터의 내적(Dot Product)
- 단위 벡터
    - 크기가 1인 벡터
    - 단위 벡터 중 방향 관계를 결정하기 위한 벡터를 "방향벡터"라고 한다.
        - 방향벡터 = 목적지 - 시작점을 정규화
    - 정규화란(Normalize), 어떠한 벡터를 크기가 1인 벡터로 만드는 것
        - 각 벡터(x, y, z)에 스칼라 값을 나눠준다.
- 벡터의 곱하기는 내적, 외적 2종류가 있다.


``` c#
public class DerectionVector3 : MonoBehaviour {
    Vector3 vStart;
    Vector3 vEnd = Vector3.zero;
    Vector3 vDir = Vector3.zero;

    void Start()
    {
        // 주어진 시작점에서 주어진 끝점까지의 방향벡터 구하기
        vStart = new Vector3(-3f, 2f, 4f);
        vEnd = new Vector3(10f, 10f, 10f);
        vDir = vEnd - vStart;
        Debug.Log(vDir.normalized);

        // 현재 위치에서 주어진 끝점까지의 방향벡터 구하기
        vDir = vEnd - transform.position;
        Debug.Log(vDir.normalized);
    }
}
```


### 벡터의 내적 (Dot Product)
- 기호 • (dot 라고 읽는다)
- 두 벡터의 방향관계를 계산할때 사용 (cos값을 얻을 수 있어서 각도를 구할 수 있다 )
- 계산결과는 스칼라
- 공식

![image](https://user-images.githubusercontent.com/55589616/210039750-06a48291-3f22-4865-b640-ca0e8fc96d60.png)

- 각도 구하기
    - 벡터의 내적을 이용
        - 벡터의 내적의 반환값은 각도가 아니며 각도를 구하기 위해서는 아크코사인 연산을 해야 한다
        - 게임오브젝트의 앞, 뒤 판정 할 때 사용
    - 유니티 Vector3.Angle()함수 사용
        -  Angle함수를 사용하지만 내부적으로는 내적을 연산한다.
        - 각도를 리턴(반환)


![image](https://user-images.githubusercontent.com/55589616/210039097-afafb845-82dd-469f-9582-874517489664.png)


``` c#
public Transform other;
void Update() 
{ 
    if (other) 
    { 
        Vector3 forward = transform.TransformDirection(Vector3.forward); 
        Vector3 toOther = other.position - transform.position;
        if (Vector3.Dot(forward, toOther) < 0) 
        { 
            print("The other transform is behind me!"); 
        } 
    } 
}
```


### 벡터의 외적 (cross Product)
- 기호 X (cross라고 읽는다 )
- 두 벡터에 수직인 벡터를 구할때 사용


## 9) 게임 오브젝트의 위치, 회전, 크기
- 인스펙터 창에 있는 게임오브젝트의 Transform의 각 값은 지역 좌표이다.


``` c#
public class Vector3Example : MonoBehaviour {
    void Start()
    {
        Vector3 tmpPos = new Vector3(10f, 10f, 10f);
        Debug.Log("tmpPos의 값 = " + tmpPos.x + tmpPos.y + tmpPos.z);
        Debug.Log("이름 = " + gameObject.name);
        Debug.Log("전역좌표 = " + transform.position);
        Debug.Log("지역좌표 = " + transform.localPosition);
        Debug.Log("전역회전값(도단위) = " + transform.eulerAngles);
        Debug.Log("지역회전값(도단위) = " + transform.localEulerAngles);
        Debug.Log("크기 = " + transform.localScale);
    }
}
```


## 10) 월드 변환 행렬
- 이동행렬(T), 회전행렬(R), 크기행렬(S)
- 월드에 게임오브젝트가 올려질때 월드변환행렬이 적용된다.
- 변환행렬은 S * R * T 또는 T * R * S 순으로 곱해야 한다.
    - OpenGL과 DirectX 방식에서 표현방법이 다르다.
- 이동변환 행렬 (T)
    - 이동변환 행렬의 대각 성분 dx, dy, dz는 이동량을 의미한다.

    ![image](https://user-images.githubusercontent.com/55589616/210024501-9de3bfbe-eddf-4725-bf51-a266535e12da.png)

- 회전변환 행렬 (R)

    ![image](https://user-images.githubusercontent.com/55589616/210024952-b6cc72d5-f747-456a-b273-1213e9c482e1.png)

- 크기변환 행렬 (S)
    - 크기변환행렬에서 a, b, c의 값이 각 성분의 scale값을 의미한다.

    ![image](https://user-images.githubusercontent.com/55589616/210024607-5c9dd962-1e75-40ec-bfee-778b18f3663c.png)

